// Generated from /aggregate_sdk_5.11.00/src/com/tibbo/aggregate/common/expression/Evaluator.java

#pragma once

#include <string>

class Evaluator
{
private:
    static const std::string ENVIRONMENT_PREVIOUS_;
    static const std::string ENVIRONMENT_COUNT_;
    EnvironmentReferenceResolver* environmentResolver;
    std::map resolvers;
    std::map customFunctions;
    util::Tracer* tracer;
    long count;
    void* previousResult;
protected:
    void ctor(ContextManager* cm, CallerController* caller);
    void ctor(DataTable* defaultTable);
    void ctor(ContextManager* cm, Context* defaultContext, DataTable* defaultTable, CallerController* caller);
    void ctor(ReferenceResolver* resolver);

private:
    void init(ReferenceResolver* defaultResolver);

public:
    void* evaluate(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    void* evaluate(Expression* expression, EvaluationEnvironment* environment) /* throws(SyntaxErrorException, EvaluationException) */;
    const std::string & evaluateToString(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    const std::string & evaluateToStringOrNull(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    bool evaluateToBoolean(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    ::java::lang::Boolean* evaluateToBooleanOrNull(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    ::java::lang::Number* evaluateToNumber(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    ::java::lang::Number* evaluateToNumber(Expression* expression, bool validate, bool allowNull) /* throws(SyntaxErrorException, EvaluationException) */;
    ::java::lang::Comparable* evaluateToComparable(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    DataTable* evaluateToDataTable(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    Date* evaluateToDate(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    ::java::awt::Color* evaluateToColor(Expression* expression) /* throws(SyntaxErrorException, EvaluationException) */;
    ReferenceResolver* getResolver(const std::string & schema);
    ReferenceResolver* getDefaultResolver();
    void setResolver(const std::string & schema, ReferenceResolver* resolver);
    std::map getResolvers();
    void* getPreviousResult();
    void setPreviousResult(void* previousResult);
    void registerCustomFunction(const std::string & name, Function* impl);
    std::map getAllFunctions();
    Function* getCustomFunction(const std::string & name);
    EnvironmentReferenceResolver* getEnvironmentResolver();
    util::Tracer* getTracer();
    void setTracer(util::Tracer* tracer);

    // Generated
    Evaluator(ContextManager* cm, CallerController* caller);
    Evaluator(DataTable* defaultTable);
    Evaluator(ContextManager* cm, Context* defaultContext, DataTable* defaultTable, CallerController* caller);
    Evaluator(ReferenceResolver* resolver);
protected:
    Evaluator(const ::default_init_tag&);


public:
    
    static void

private:
    void init();
    static const std::string& ENVIRONMENT_PREVIOUS();
    static const std::string& ENVIRONMENT_COUNT();
    ::java::lang::Class* getClass0();
    friend class Evaluator_LocalEnvironmentResolver;
};
